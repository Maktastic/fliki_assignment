/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/success/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fapp%2Fnode_modules%2Fjotai%2Fesm%2Freact.mjs%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fapp%2Fnode_modules%2Fjotai%2Fesm%2Freact.mjs%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/jotai/esm/react.mjs */ \"(app-pages-browser)/./node_modules/jotai/esm/react.mjs\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGYXBwJTJGbm9kZV9tb2R1bGVzJTJGam90YWklMkZlc20lMkZyZWFjdC5tanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4TEFBMEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9kYmRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2FwcC9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fapp%2Fnode_modules%2Fjotai%2Fesm%2Freact.mjs%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: function() { return /* binding */ Provider; },\n/* harmony export */   useAtom: function() { return /* binding */ useAtom; },\n/* harmony export */   useAtomValue: function() { return /* binding */ useAtomValue; },\n/* harmony export */   useSetAtom: function() { return /* binding */ useSetAtom; },\n/* harmony export */   useStore: function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(app-pages-browser)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$();\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    _s();\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\n_s(useStore, \"Wl1jJrZzTCxjtMcqth/dX4wg3Uo=\");\nconst Provider = (param)=>{\n    let { children, store } = param;\n    _s1();\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\n_s1(Provider, \"EtiU7pDwGhTDZwMnrKEqZbxjqXE=\");\n_c = Provider;\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    _s2();\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\n_s2(useAtomValue, \"1uk+Y9a78As5DspzFTGKs8amIyM=\", false, function() {\n    return [\n        useStore\n    ];\n});\nfunction useSetAtom(atom, options) {\n    _s3();\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\n_s3(useSetAtom, \"Pn+Qt5Bv6ZjW7g23e6pLgnE3PKk=\", false, function() {\n    return [\n        useStore\n    ];\n});\nfunction useAtom(atom, options) {\n    _s4();\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n_s4(useAtom, \"+d8xoddIKQXMn74fLgw78AhLuew=\", false, function() {\n    return [\n        useAtomValue,\n        useSetAtom\n    ];\n});\n\nvar _c;\n$RefreshReg$(_c, \"Provider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQzBJO0FBQzdFO0FBRTdELE1BQU1XLDZCQUFlVixvREFBYUEsQ0FDaEMsS0FBSztBQUVQLE1BQU1XLFdBQVcsQ0FBQ0M7O0lBQ2hCLE1BQU1DLFFBQVFaLGlEQUFVQSxDQUFDUztJQUN6QixPQUFPLENBQUNFLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLEtBQUssS0FBS0EsU0FBU0wsOERBQWVBO0FBQy9FO0dBSE1HO0FBSU4sTUFBTUcsV0FBVztRQUFDLEVBQ2hCQyxRQUFRLEVBQ1JGLEtBQUssRUFDTjs7SUFDQyxNQUFNRyxXQUFXZCw2Q0FBTUE7SUFDdkIsSUFBSSxDQUFDVyxTQUFTLENBQUNHLFNBQVNDLE9BQU8sRUFBRTtRQUMvQkQsU0FBU0MsT0FBTyxHQUFHUiwwREFBV0E7SUFDaEM7SUFDQSxxQkFBT04sb0RBQWFBLENBQ2xCTyxhQUFhSSxRQUFRLEVBQ3JCO1FBQ0VJLE9BQU9MLFNBQVNHLFNBQVNDLE9BQU87SUFDbEMsR0FDQUY7QUFFSjtJQWZNRDtLQUFBQTtBQWlCTixNQUFNSyxnQkFBZ0IsQ0FBQ0MsSUFBTSxPQUFRQSxDQUFBQSxLQUFLLE9BQU8sS0FBSyxJQUFJQSxFQUFFQyxJQUFJLE1BQU07QUFDdEUsTUFBTUMsTUFBTXZCLHNDQUFnQixJQUFLLEVBQUN3QjtJQUNoQyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssV0FBVztRQUNoQyxNQUFNRDtJQUNSLE9BQU8sSUFBSUEsUUFBUUMsTUFBTSxLQUFLLGFBQWE7UUFDekMsT0FBT0QsUUFBUUwsS0FBSztJQUN0QixPQUFPLElBQUlLLFFBQVFDLE1BQU0sS0FBSyxZQUFZO1FBQ3hDLE1BQU1ELFFBQVFFLE1BQU07SUFDdEIsT0FBTztRQUNMRixRQUFRQyxNQUFNLEdBQUc7UUFDakJELFFBQVFGLElBQUksQ0FDVixDQUFDSztZQUNDSCxRQUFRQyxNQUFNLEdBQUc7WUFDakJELFFBQVFMLEtBQUssR0FBR1E7UUFDbEIsR0FDQSxDQUFDQztZQUNDSixRQUFRQyxNQUFNLEdBQUc7WUFDakJELFFBQVFFLE1BQU0sR0FBR0U7UUFDbkI7UUFFRixNQUFNSjtJQUNSO0FBQ0Y7QUFDQSxTQUFTSyxhQUFhQyxJQUFJLEVBQUVqQixPQUFPOztJQUNqQyxNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNLENBQUMsQ0FBQ2tCLGtCQUFrQkMsa0JBQWtCQyxnQkFBZ0IsRUFBRUMsU0FBUyxHQUFHN0IsaURBQVVBLENBQ2xGLENBQUM4QjtRQUNDLE1BQU1DLFlBQVl0QixNQUFNdUIsR0FBRyxDQUFDUDtRQUM1QixJQUFJUSxPQUFPQyxFQUFFLENBQUNKLElBQUksQ0FBQyxFQUFFLEVBQUVDLGNBQWNELElBQUksQ0FBQyxFQUFFLEtBQUtyQixTQUFTcUIsSUFBSSxDQUFDLEVBQUUsS0FBS0wsTUFBTTtZQUMxRSxPQUFPSztRQUNUO1FBQ0EsT0FBTztZQUFDQztZQUFXdEI7WUFBT2dCO1NBQUs7SUFDakMsR0FDQSxLQUFLLEdBQ0wsSUFBTTtZQUFDaEIsTUFBTXVCLEdBQUcsQ0FBQ1A7WUFBT2hCO1lBQU9nQjtTQUFLO0lBRXRDLElBQUlYLFFBQVFZO0lBQ1osSUFBSUMscUJBQXFCbEIsU0FBU21CLG9CQUFvQkgsTUFBTTtRQUMxREk7UUFDQWYsUUFBUUwsTUFBTXVCLEdBQUcsQ0FBQ1A7SUFDcEI7SUFDQSxNQUFNVSxRQUFRM0IsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUTJCLEtBQUs7SUFDdERsQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1tQyxRQUFRM0IsTUFBTTRCLEdBQUcsQ0FBQ1osTUFBTTtZQUM1QixJQUFJLE9BQU9VLFVBQVUsVUFBVTtnQkFDN0JHLFdBQVdULFVBQVVNO2dCQUNyQjtZQUNGO1lBQ0FOO1FBQ0Y7UUFDQUE7UUFDQSxPQUFPTztJQUNULEdBQUc7UUFBQzNCO1FBQU9nQjtRQUFNVTtLQUFNO0lBQ3ZCakMsb0RBQWFBLENBQUNZO0lBQ2QsT0FBT0MsY0FBY0QsU0FBU0ksSUFBSUosU0FBU0E7QUFDN0M7SUFoQ1NVOztRQUNPakI7OztBQWlDaEIsU0FBU2dDLFdBQVdkLElBQUksRUFBRWpCLE9BQU87O0lBQy9CLE1BQU1DLFFBQVFGLFNBQVNDO0lBQ3ZCLE1BQU1nQyxVQUFVckMsa0RBQVdBLENBQ3pCO3lDQUFJc0M7WUFBQUE7O1FBQ0YsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxnQkFBZ0IsQ0FBRSxZQUFXaEIsSUFBRyxHQUFJO1lBQzVGLE1BQU0sSUFBSW1CLE1BQU07UUFDbEI7UUFDQSxPQUFPbkMsTUFBTW9DLEdBQUcsQ0FBQ3BCLFNBQVNnQjtJQUM1QixHQUNBO1FBQUNoQztRQUFPZ0I7S0FBSztJQUVmLE9BQU9lO0FBQ1Q7SUFaU0Q7O1FBQ09oQzs7O0FBYWhCLFNBQVN1QyxRQUFRckIsSUFBSSxFQUFFakIsT0FBTzs7SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0lBTlNzQzs7UUFFTHRCO1FBRUFlOzs7QUFJNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9yZWFjdC5tanM/YWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKSA9PiB7XG4gIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICB9IGVsc2Uge1xuICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgcHJvbWlzZS50aGVuKFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBbW3ZhbHVlRnJvbVJlZHVjZXIsIHN0b3JlRnJvbVJlZHVjZXIsIGF0b21Gcm9tUmVkdWNlcl0sIHJlcmVuZGVyXSA9IHVzZVJlZHVjZXIoXG4gICAgKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlswXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzFdID09PSBzdG9yZSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmFsdWUsIHN0b3JlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICAoKSA9PiBbc3RvcmUuZ2V0KGF0b20pLCBzdG9yZSwgYXRvbV1cbiAgKTtcbiAgbGV0IHZhbHVlID0gdmFsdWVGcm9tUmVkdWNlcjtcbiAgaWYgKHN0b3JlRnJvbVJlZHVjZXIgIT09IHN0b3JlIHx8IGF0b21Gcm9tUmVkdWNlciAhPT0gYXRvbSkge1xuICAgIHJlcmVuZGVyKCk7XG4gICAgdmFsdWUgPSBzdG9yZS5nZXQoYXRvbSk7XG4gIH1cbiAgY29uc3QgZGVsYXkgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRlbGF5O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3ViKGF0b20sICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgPyB1c2UodmFsdWUpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucykge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKG9wdGlvbnMpO1xuICBjb25zdCBzZXRBdG9tID0gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhKFwid3JpdGVcIiBpbiBhdG9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3Qgd3JpdGFibGUgYXRvbVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG9yZS5zZXQoYXRvbSwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBbc3RvcmUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB1c2VBdG9tVmFsdWUoYXRvbSwgb3B0aW9ucyksXG4gICAgLy8gV2UgZG8gd3JvbmcgdHlwZSBhc3NlcnRpb24gaGVyZSwgd2hpY2ggcmVzdWx0cyBpbiB0aHJvd2luZyBhbiBlcnJvci5cbiAgICB1c2VTZXRBdG9tKGF0b20sIG9wdGlvbnMpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCB1c2VBdG9tLCB1c2VBdG9tVmFsdWUsIHVzZVNldEF0b20sIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOlsiUmVhY3RFeHBvcnRzIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJjcmVhdGVFbGVtZW50IiwidXNlUmVkdWNlciIsInVzZUVmZmVjdCIsInVzZURlYnVnVmFsdWUiLCJ1c2VDYWxsYmFjayIsImdldERlZmF1bHRTdG9yZSIsImNyZWF0ZVN0b3JlIiwiU3RvcmVDb250ZXh0IiwidXNlU3RvcmUiLCJvcHRpb25zIiwic3RvcmUiLCJQcm92aWRlciIsImNoaWxkcmVuIiwic3RvcmVSZWYiLCJjdXJyZW50IiwidmFsdWUiLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJ1c2UiLCJwcm9taXNlIiwic3RhdHVzIiwicmVhc29uIiwidiIsImUiLCJ1c2VBdG9tVmFsdWUiLCJhdG9tIiwidmFsdWVGcm9tUmVkdWNlciIsInN0b3JlRnJvbVJlZHVjZXIiLCJhdG9tRnJvbVJlZHVjZXIiLCJyZXJlbmRlciIsInByZXYiLCJuZXh0VmFsdWUiLCJnZXQiLCJPYmplY3QiLCJpcyIsImRlbGF5IiwidW5zdWIiLCJzdWIiLCJzZXRUaW1lb3V0IiwidXNlU2V0QXRvbSIsInNldEF0b20iLCJhcmdzIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jotai/esm/react.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: function() { return /* binding */ atom; },\n/* harmony export */   createStore: function() { return /* binding */ createStore; },\n/* harmony export */   getDefaultStore: function() { return /* binding */ getDefaultStore; }\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return ( false ? 0 : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst CONTINUE_PROMISE = Symbol(\n  ( false ? 0 : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\nconst isContinuablePromise = (promise) => typeof promise === \"object\" && promise !== null && CONTINUE_PROMISE in promise;\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, abort, complete) => {\n  if (!continuablePromiseMap.has(promise)) {\n    let continuePromise;\n    const p = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          p.status = FULFILLED;\n          p.value = v;\n          resolve(v);\n          complete();\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          p.status = REJECTED;\n          p.reason = e;\n          reject(e);\n          complete();\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      continuePromise = (nextPromise, nextAbort) => {\n        if (nextPromise) {\n          continuablePromiseMap.set(nextPromise, p);\n          curr = nextPromise;\n          nextPromise.then(onFulfilled(nextPromise), onRejected(nextPromise));\n          abort();\n          abort = nextAbort;\n        }\n      };\n    });\n    p.status = PENDING;\n    p[CONTINUE_PROMISE] = continuePromise;\n    continuablePromiseMap.set(promise, p);\n  }\n  return continuablePromiseMap.get(promise);\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if (( false ? 0 : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst getPendingContinuablePromise = (atomState) => {\n  const value = atomState.v;\n  if (isContinuablePromise(value) && value.status === PENDING) {\n    return value;\n  }\n  return null;\n};\nconst addPendingContinuablePromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\nconst addPendingAtom = (pending, atom, atomState) => {\n  if (!pending[0].has(atom)) {\n    pending[0].set(atom, /* @__PURE__ */ new Set());\n  }\n  pending[1].set(atom, atomState);\n};\nconst addPendingDependent = (pending, atom, dependent) => {\n  const dependents = pending[0].get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\nconst addPendingFunction = (pending, fn) => {\n  pending[2].add(fn);\n};\nconst flushPending = (pending) => {\n  while (pending[1].size || pending[2].size) {\n    pending[0].clear();\n    const atomStates = new Set(pending[1].values());\n    pending[1].clear();\n    const functions = new Set(pending[2]);\n    pending[2].clear();\n    atomStates.forEach((atomState) => {\n      var _a;\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach((l) => l());\n    });\n    functions.forEach((fn) => fn());\n  }\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  let debugMountedAtoms;\n  if (( false ? 0 : void 0) !== \"production\") {\n    debugMountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => {\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise, abortPromise = () => {\n  }, completePromise = () => {\n  }) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = getPendingContinuablePromise(atomState);\n    if (isPromiseLike(valueOrPromise)) {\n      if (pendingPromise) {\n        if (pendingPromise !== valueOrPromise) {\n          pendingPromise[CONTINUE_PROMISE](valueOrPromise, abortPromise);\n          ++atomState.n;\n        }\n      } else {\n        const continuablePromise = createContinuablePromise(\n          valueOrPromise,\n          abortPromise,\n          completePromise\n        );\n        if (continuablePromise.status === PENDING) {\n          for (const a of atomState.d.keys()) {\n            const aState = getAtomState(a);\n            addPendingContinuablePromiseToDependency(\n              atom,\n              continuablePromise,\n              aState\n            );\n          }\n        }\n        atomState.v = continuablePromise;\n        delete atomState.e;\n      }\n    } else {\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](\n          Promise.resolve(valueOrPromise),\n          abortPromise\n        );\n      }\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    }\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n    }\n  };\n  const addDependency = (pending, atom, a, aState) => {\n    var _a;\n    if (( false ? 0 : void 0) !== \"production\" && a === atom) {\n      throw new Error(\"[Bug] atom cannot depend on itself\");\n    }\n    const atomState = getAtomState(atom);\n    atomState.d.set(a, aState.n);\n    const continuablePromise = getPendingContinuablePromise(atomState);\n    if (continuablePromise) {\n      addPendingContinuablePromiseToDependency(atom, continuablePromise, aState);\n    }\n    (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n    if (pending) {\n      addPendingDependent(pending, a, atom);\n    }\n  };\n  const readAtomState = (pending, atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && isAtomStateInitialized(atomState)) {\n      if (atomState.m) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(pending, a, force).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(pending, a, force);\n      if (isSync) {\n        addDependency(pending, atom, a, aState);\n      } else {\n        const pending2 = createPending();\n        addDependency(pending2, atom, a, aState);\n        mountDependencies(pending2, atom, atomState);\n        flushPending(pending2);\n      }\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if (( false ? 0 : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      setAtomStateValueOrPromise(\n        atom,\n        atomState,\n        valueOrPromise,\n        () => controller == null ? void 0 : controller.abort(),\n        () => {\n          if (atomState.m) {\n            const pending2 = createPending();\n            mountDependencies(pending2, atom, atomState);\n            flushPending(pending2);\n          }\n        }\n      );\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\n  const recomputeDependents = (pending, atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const aState = getAtomState(a);\n      const dependents = new Set((_a = aState.m) == null ? void 0 : _a.t);\n      for (const atomWithPendingContinuablePromise of aState.p) {\n        dependents.add(atomWithPendingContinuablePromise);\n      }\n      (_b = getPendingDependents(pending, a)) == null ? void 0 : _b.forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = [];\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const aState = getAtomState(a);\n      const prevEpochNumber = aState.n;\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(pending, a, isMarked);\n        mountDependencies(pending, a, aState);\n        if (prevEpochNumber !== aState.n) {\n          addPendingAtom(pending, a, aState);\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (pending, atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(pending, a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const aState = getAtomState(a);\n        const hasPrevValue = \"v\" in aState;\n        const prevValue = aState.v;\n        const v = args2[0];\n        setAtomStateValueOrPromise(a, aState, v);\n        mountDependencies(pending, a, aState);\n        if (!hasPrevValue || !Object.is(prevValue, aState.v)) {\n          addPendingAtom(pending, a, aState);\n          recomputeDependents(pending, a);\n        }\n      } else {\n        r = writeAtomState(pending, a, ...args2);\n      }\n      flushPending(pending);\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const pending = createPending();\n    const result = writeAtomState(pending, atom, ...args);\n    flushPending(pending);\n    return result;\n  };\n  const mountDependencies = (pending, atom, atomState) => {\n    if (atomState.m && !getPendingContinuablePromise(atomState)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(pending, a);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(pending, a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (!atomState.m) {\n      readAtomState(pending, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(pending, a);\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.add(atom);\n      }\n      if (isActuallyWritableAtom(atom) && atom.onMount) {\n        const mounted = atomState.m;\n        const { onMount } = atom;\n        addPendingFunction(pending, () => {\n          const onUnmount = onMount(\n            (...args) => writeAtomState(pending, atom, ...args)\n          );\n          if (onUnmount) {\n            mounted.u = onUnmount;\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a;\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addPendingFunction(pending, onUnmount);\n      }\n      delete atomState.m;\n      if (( false ? 0 : void 0) !== \"production\") {\n        debugMountedAtoms.delete(atom);\n      }\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(pending, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      const pendingPromise = getPendingContinuablePromise(atomState);\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](void 0, () => {\n        });\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const pending = createPending();\n    const mounted = mountAtom(pending, atom);\n    flushPending(pending);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      const pending2 = createPending();\n      unmountAtom(pending2, atom);\n      flushPending(pending2);\n    };\n  };\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n  if (( false ? 0 : void 0) !== \"production\") {\n    const devStore = {\n      // store dev methods (these are tentative and subject to change without notice)\n      dev4_get_internal_weak_map: () => atomStateMap,\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\n      dev4_restore_atoms: (values) => {\n        const pending = createPending();\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            const atomState = getAtomState(atom);\n            const hasPrevValue = \"v\" in atomState;\n            const prevValue = atomState.v;\n            setAtomStateValueOrPromise(atom, atomState, value);\n            mountDependencies(pending, atom, atomState);\n            if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n              addPendingAtom(pending, atom, atomState);\n              recomputeDependents(pending, atom);\n            }\n          }\n        }\n        flushPending(pending);\n      }\n    };\n    Object.assign(store, devStore);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if (( false ? 0 : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qb3RhaS9lc20vdmFuaWxsYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLE1BQWUsR0FBRyxDQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLE1BQWUsR0FBRyxDQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE1BQWUsR0FBRyxDQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFlLEdBQUcsQ0FBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhLE1BQWUsR0FBRyxDQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFlLEdBQUcsQ0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBZSxHQUFHLENBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQWUsR0FBRyxDQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBZSxHQUFHLENBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBZSxHQUFHLENBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzP2MzOTYiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuZGVidWdMYWJlbCA/IGtleSArIFwiOlwiICsgdGhpcy5kZWJ1Z0xhYmVsIDoga2V5O1xuICAgIH1cbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gZGVmYXVsdFJlYWQ7XG4gICAgY29uZmlnLndyaXRlID0gZGVmYXVsdFdyaXRlO1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVhZChnZXQpIHtcbiAgcmV0dXJuIGdldCh0aGlzKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZShnZXQsIHNldCwgYXJnKSB7XG4gIHJldHVybiBzZXQoXG4gICAgdGhpcyxcbiAgICB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoZ2V0KHRoaXMpKSA6IGFyZ1xuICApO1xufVxuXG5jb25zdCBpc1NlbGZBdG9tID0gKGF0b20sIGEpID0+IGF0b20udW5zdGFibGVfaXMgPyBhdG9tLnVuc3RhYmxlX2lzKGEpIDogYSA9PT0gYXRvbTtcbmNvbnN0IGhhc0luaXRpYWxWYWx1ZSA9IChhdG9tKSA9PiBcImluaXRcIiBpbiBhdG9tO1xuY29uc3QgaXNBY3R1YWxseVdyaXRhYmxlQXRvbSA9IChhdG9tKSA9PiAhIWF0b20ud3JpdGU7XG5jb25zdCBDT05USU5VRV9QUk9NSVNFID0gU3ltYm9sKFxuICAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ09OVElOVUVfUFJPTUlTRVwiIDogXCJcIlxuKTtcbmNvbnN0IFBFTkRJTkcgPSBcInBlbmRpbmdcIjtcbmNvbnN0IEZVTEZJTExFRCA9IFwiZnVsZmlsbGVkXCI7XG5jb25zdCBSRUpFQ1RFRCA9IFwicmVqZWN0ZWRcIjtcbmNvbnN0IGlzQ29udGludWFibGVQcm9taXNlID0gKHByb21pc2UpID0+IHR5cGVvZiBwcm9taXNlID09PSBcIm9iamVjdFwiICYmIHByb21pc2UgIT09IG51bGwgJiYgQ09OVElOVUVfUFJPTUlTRSBpbiBwcm9taXNlO1xuY29uc3QgY29udGludWFibGVQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjcmVhdGVDb250aW51YWJsZVByb21pc2UgPSAocHJvbWlzZSwgYWJvcnQsIGNvbXBsZXRlKSA9PiB7XG4gIGlmICghY29udGludWFibGVQcm9taXNlTWFwLmhhcyhwcm9taXNlKSkge1xuICAgIGxldCBjb250aW51ZVByb21pc2U7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjdXJyID0gcHJvbWlzZTtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gKG1lKSA9PiAodikgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICBwLnN0YXR1cyA9IEZVTEZJTExFRDtcbiAgICAgICAgICBwLnZhbHVlID0gdjtcbiAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBvblJlamVjdGVkID0gKG1lKSA9PiAoZSkgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICBwLnN0YXR1cyA9IFJFSkVDVEVEO1xuICAgICAgICAgIHAucmVhc29uID0gZTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHByb21pc2UudGhlbihvbkZ1bGZpbGxlZChwcm9taXNlKSwgb25SZWplY3RlZChwcm9taXNlKSk7XG4gICAgICBjb250aW51ZVByb21pc2UgPSAobmV4dFByb21pc2UsIG5leHRBYm9ydCkgPT4ge1xuICAgICAgICBpZiAobmV4dFByb21pc2UpIHtcbiAgICAgICAgICBjb250aW51YWJsZVByb21pc2VNYXAuc2V0KG5leHRQcm9taXNlLCBwKTtcbiAgICAgICAgICBjdXJyID0gbmV4dFByb21pc2U7XG4gICAgICAgICAgbmV4dFByb21pc2UudGhlbihvbkZ1bGZpbGxlZChuZXh0UHJvbWlzZSksIG9uUmVqZWN0ZWQobmV4dFByb21pc2UpKTtcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGFib3J0ID0gbmV4dEFib3J0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHAuc3RhdHVzID0gUEVORElORztcbiAgICBwW0NPTlRJTlVFX1BST01JU0VdID0gY29udGludWVQcm9taXNlO1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgcCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG59O1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHZvaWQgMCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzQXRvbVN0YXRlSW5pdGlhbGl6ZWQgPSAoYXRvbVN0YXRlKSA9PiBcInZcIiBpbiBhdG9tU3RhdGUgfHwgXCJlXCIgaW4gYXRvbVN0YXRlO1xuY29uc3QgcmV0dXJuQXRvbVZhbHVlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgdGhyb3cgYXRvbVN0YXRlLmU7XG4gIH1cbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ2XCIgaW4gYXRvbVN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gc3RhdGUgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG4gIHJldHVybiBhdG9tU3RhdGUudjtcbn07XG5jb25zdCBnZXRQZW5kaW5nQ29udGludWFibGVQcm9taXNlID0gKGF0b21TdGF0ZSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGF0b21TdGF0ZS52O1xuICBpZiAoaXNDb250aW51YWJsZVByb21pc2UodmFsdWUpICYmIHZhbHVlLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5ID0gKGF0b20sIHByb21pc2UsIGRlcGVuZGVuY3lBdG9tU3RhdGUpID0+IHtcbiAgaWYgKCFkZXBlbmRlbmN5QXRvbVN0YXRlLnAuaGFzKGF0b20pKSB7XG4gICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmFkZChhdG9tKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lBdG9tU3RhdGUucC5kZWxldGUoYXRvbSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5QXRvbVN0YXRlLnAuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVQZW5kaW5nID0gKCkgPT4gWy8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldO1xuY29uc3QgYWRkUGVuZGluZ0F0b20gPSAocGVuZGluZywgYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gIGlmICghcGVuZGluZ1swXS5oYXMoYXRvbSkpIHtcbiAgICBwZW5kaW5nWzBdLnNldChhdG9tLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICBwZW5kaW5nWzFdLnNldChhdG9tLCBhdG9tU3RhdGUpO1xufTtcbmNvbnN0IGFkZFBlbmRpbmdEZXBlbmRlbnQgPSAocGVuZGluZywgYXRvbSwgZGVwZW5kZW50KSA9PiB7XG4gIGNvbnN0IGRlcGVuZGVudHMgPSBwZW5kaW5nWzBdLmdldChhdG9tKTtcbiAgaWYgKGRlcGVuZGVudHMpIHtcbiAgICBkZXBlbmRlbnRzLmFkZChkZXBlbmRlbnQpO1xuICB9XG59O1xuY29uc3QgZ2V0UGVuZGluZ0RlcGVuZGVudHMgPSAocGVuZGluZywgYXRvbSkgPT4gcGVuZGluZ1swXS5nZXQoYXRvbSk7XG5jb25zdCBhZGRQZW5kaW5nRnVuY3Rpb24gPSAocGVuZGluZywgZm4pID0+IHtcbiAgcGVuZGluZ1syXS5hZGQoZm4pO1xufTtcbmNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nKSA9PiB7XG4gIHdoaWxlIChwZW5kaW5nWzFdLnNpemUgfHwgcGVuZGluZ1syXS5zaXplKSB7XG4gICAgcGVuZGluZ1swXS5jbGVhcigpO1xuICAgIGNvbnN0IGF0b21TdGF0ZXMgPSBuZXcgU2V0KHBlbmRpbmdbMV0udmFsdWVzKCkpO1xuICAgIHBlbmRpbmdbMV0uY2xlYXIoKTtcbiAgICBjb25zdCBmdW5jdGlvbnMgPSBuZXcgU2V0KHBlbmRpbmdbMl0pO1xuICAgIHBlbmRpbmdbMl0uY2xlYXIoKTtcbiAgICBhdG9tU3RhdGVzLmZvckVhY2goKGF0b21TdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGF0b21TdGF0ZS5tKSA9PSBudWxsID8gdm9pZCAwIDogX2EubC5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9ucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9ICgpID0+IHtcbiAgY29uc3QgYXRvbVN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGxldCBkZWJ1Z01vdW50ZWRBdG9tcztcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZGVidWdNb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9IChhdG9tKSA9PiB7XG4gICAgbGV0IGF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICAgIGF0b21TdGF0ZSA9IHsgZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbjogMCB9O1xuICAgICAgYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCBhdG9tU3RhdGUsIHZhbHVlT3JQcm9taXNlLCBhYm9ydFByb21pc2UgPSAoKSA9PiB7XG4gIH0sIGNvbXBsZXRlUHJvbWlzZSA9ICgpID0+IHtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFwidlwiIGluIGF0b21TdGF0ZTtcbiAgICBjb25zdCBwcmV2VmFsdWUgPSBhdG9tU3RhdGUudjtcbiAgICBjb25zdCBwZW5kaW5nUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2UgIT09IHZhbHVlT3JQcm9taXNlKSB7XG4gICAgICAgICAgcGVuZGluZ1Byb21pc2VbQ09OVElOVUVfUFJPTUlTRV0odmFsdWVPclByb21pc2UsIGFib3J0UHJvbWlzZSk7XG4gICAgICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGludWFibGVQcm9taXNlID0gY3JlYXRlQ29udGludWFibGVQcm9taXNlKFxuICAgICAgICAgIHZhbHVlT3JQcm9taXNlLFxuICAgICAgICAgIGFib3J0UHJvbWlzZSxcbiAgICAgICAgICBjb21wbGV0ZVByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGNvbnRpbnVhYmxlUHJvbWlzZS5zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgICAgICBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5KFxuICAgICAgICAgICAgICBhdG9tLFxuICAgICAgICAgICAgICBjb250aW51YWJsZVByb21pc2UsXG4gICAgICAgICAgICAgIGFTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXRvbVN0YXRlLnYgPSBjb250aW51YWJsZVByb21pc2U7XG4gICAgICAgIGRlbGV0ZSBhdG9tU3RhdGUuZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlbmRpbmdQcm9taXNlKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlW0NPTlRJTlVFX1BST01JU0VdKFxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZU9yUHJvbWlzZSksXG4gICAgICAgICAgYWJvcnRQcm9taXNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBhdG9tU3RhdGUudiA9IHZhbHVlT3JQcm9taXNlO1xuICAgICAgZGVsZXRlIGF0b21TdGF0ZS5lO1xuICAgIH1cbiAgICBpZiAoIWhhc1ByZXZWYWx1ZSB8fCAhT2JqZWN0LmlzKHByZXZWYWx1ZSwgYXRvbVN0YXRlLnYpKSB7XG4gICAgICArK2F0b21TdGF0ZS5uO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYWRkRGVwZW5kZW5jeSA9IChwZW5kaW5nLCBhdG9tLCBhLCBhU3RhdGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGEgPT09IGF0b20pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGF0b20gY2Fubm90IGRlcGVuZCBvbiBpdHNlbGZcIik7XG4gICAgfVxuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBhdG9tU3RhdGUuZC5zZXQoYSwgYVN0YXRlLm4pO1xuICAgIGNvbnN0IGNvbnRpbnVhYmxlUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICBpZiAoY29udGludWFibGVQcm9taXNlKSB7XG4gICAgICBhZGRQZW5kaW5nQ29udGludWFibGVQcm9taXNlVG9EZXBlbmRlbmN5KGF0b20sIGNvbnRpbnVhYmxlUHJvbWlzZSwgYVN0YXRlKTtcbiAgICB9XG4gICAgKF9hID0gYVN0YXRlLm0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50LmFkZChhdG9tKTtcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgYWRkUGVuZGluZ0RlcGVuZGVudChwZW5kaW5nLCBhLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAocGVuZGluZywgYXRvbSwgZm9yY2UpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCEoZm9yY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcmNlKGF0b20pKSAmJiBpc0F0b21TdGF0ZUluaXRpYWxpemVkKGF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChhdG9tU3RhdGUubSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KFxuICAgICAgICAoW2EsIG5dKSA9PiAoXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHksIHJlYWQgdGhlIGF0b20gc3RhdGUgb2YgdGhlIGRlcGVuZGVuY3ksIGFuZFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdG9tIGVwb2NoIG51bWJlciBpcyB1bmNoYW5nZWRcbiAgICAgICAgICByZWFkQXRvbVN0YXRlKHBlbmRpbmcsIGEsIGZvcmNlKS5uID09PSBuXG4gICAgICAgIClcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXRvbVN0YXRlLmQuY2xlYXIoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKCFpc0F0b21TdGF0ZUluaXRpYWxpemVkKGFTdGF0ZTIpKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYSwgYVN0YXRlMiwgYS5pbml0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShwZW5kaW5nLCBhLCBmb3JjZSk7XG4gICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgIGFkZERlcGVuZGVuY3kocGVuZGluZywgYXRvbSwgYSwgYVN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcyID0gY3JlYXRlUGVuZGluZygpO1xuICAgICAgICBhZGREZXBlbmRlbmN5KHBlbmRpbmcyLCBhdG9tLCBhLCBhU3RhdGUpO1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nMiwgYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5BdG9tVmFsdWUoYVN0YXRlKTtcbiAgICB9O1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzZXRTZWxmO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIH0sXG4gICAgICBnZXQgc2V0U2VsZigpIHtcbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNldFNlbGYgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCBpbiBzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTZWxmO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlT3JQcm9taXNlID0gYXRvbS5yZWFkKGdldHRlciwgb3B0aW9ucyk7XG4gICAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShcbiAgICAgICAgYXRvbSxcbiAgICAgICAgYXRvbVN0YXRlLFxuICAgICAgICB2YWx1ZU9yUHJvbWlzZSxcbiAgICAgICAgKCkgPT4gY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgaWYgKGF0b21TdGF0ZS5tKSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nMiA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKHBlbmRpbmcyLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWxldGUgYXRvbVN0YXRlLnY7XG4gICAgICBhdG9tU3RhdGUuZSA9IGVycm9yO1xuICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVhZEF0b20gPSAoYXRvbSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUodm9pZCAwLCBhdG9tKSk7XG4gIGNvbnN0IHJlY29tcHV0ZURlcGVuZGVudHMgPSAocGVuZGluZywgYXRvbSkgPT4ge1xuICAgIGNvbnN0IGdldERlcGVuZGVudHMgPSAoYSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGNvbnN0IGRlcGVuZGVudHMgPSBuZXcgU2V0KChfYSA9IGFTdGF0ZS5tKSA9PSBudWxsID8gdm9pZCAwIDogX2EudCk7XG4gICAgICBmb3IgKGNvbnN0IGF0b21XaXRoUGVuZGluZ0NvbnRpbnVhYmxlUHJvbWlzZSBvZiBhU3RhdGUucCkge1xuICAgICAgICBkZXBlbmRlbnRzLmFkZChhdG9tV2l0aFBlbmRpbmdDb250aW51YWJsZVByb21pc2UpO1xuICAgICAgfVxuICAgICAgKF9iID0gZ2V0UGVuZGluZ0RlcGVuZGVudHMocGVuZGluZywgYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChkZXBlbmRlbnQpID0+IHtcbiAgICAgICAgZGVwZW5kZW50cy5hZGQoZGVwZW5kZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlcGVuZGVudHM7XG4gICAgfTtcbiAgICBjb25zdCB0b3Bzb3J0ZWRBdG9tcyA9IFtdO1xuICAgIGNvbnN0IG1hcmtlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpdCA9IChuKSA9PiB7XG4gICAgICBpZiAobWFya2VkQXRvbXMuaGFzKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmFkZChuKTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBnZXREZXBlbmRlbnRzKG4pKSB7XG4gICAgICAgIGlmIChuICE9PSBtKSB7XG4gICAgICAgICAgdmlzaXQobSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvcHNvcnRlZEF0b21zLnB1c2gobik7XG4gICAgfTtcbiAgICB2aXNpdChhdG9tKTtcbiAgICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbYXRvbV0pO1xuICAgIGNvbnN0IGlzTWFya2VkID0gKGEpID0+IG1hcmtlZEF0b21zLmhhcyhhKTtcbiAgICBmb3IgKGxldCBpID0gdG9wc29ydGVkQXRvbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IGEgPSB0b3Bzb3J0ZWRBdG9tc1tpXTtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgIGNvbnN0IHByZXZFcG9jaE51bWJlciA9IGFTdGF0ZS5uO1xuICAgICAgbGV0IGhhc0NoYW5nZWREZXBzID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBhU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKGRlcCAhPT0gYSAmJiBjaGFuZ2VkQXRvbXMuaGFzKGRlcCkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkRGVwcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNDaGFuZ2VkRGVwcykge1xuICAgICAgICByZWFkQXRvbVN0YXRlKHBlbmRpbmcsIGEsIGlzTWFya2VkKTtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKHByZXZFcG9jaE51bWJlciAhPT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICBhZGRQZW5kaW5nQXRvbShwZW5kaW5nLCBhLCBhU3RhdGUpO1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5hZGQoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcmtlZEF0b21zLmRlbGV0ZShhKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHdyaXRlQXRvbVN0YXRlID0gKHBlbmRpbmcsIGF0b20sIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4gcmV0dXJuQXRvbVZhbHVlKHJlYWRBdG9tU3RhdGUocGVuZGluZywgYSkpO1xuICAgIGNvbnN0IHNldHRlciA9IChhLCAuLi5hcmdzMikgPT4ge1xuICAgICAgbGV0IHI7XG4gICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBpZiAoIWhhc0luaXRpYWxWYWx1ZShhKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0b20gbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYVN0YXRlO1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBhU3RhdGUudjtcbiAgICAgICAgY29uc3QgdiA9IGFyZ3MyWzBdO1xuICAgICAgICBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZShhLCBhU3RhdGUsIHYpO1xuICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nLCBhLCBhU3RhdGUpO1xuICAgICAgICBpZiAoIWhhc1ByZXZWYWx1ZSB8fCAhT2JqZWN0LmlzKHByZXZWYWx1ZSwgYVN0YXRlLnYpKSB7XG4gICAgICAgICAgYWRkUGVuZGluZ0F0b20ocGVuZGluZywgYSwgYVN0YXRlKTtcbiAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKHBlbmRpbmcsIGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gd3JpdGVBdG9tU3RhdGUocGVuZGluZywgYSwgLi4uYXJnczIpO1xuICAgICAgfVxuICAgICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVQZW5kaW5nKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gd3JpdGVBdG9tU3RhdGUocGVuZGluZywgYXRvbSwgLi4uYXJncyk7XG4gICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKHBlbmRpbmcsIGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGlmIChhdG9tU3RhdGUubSAmJiAhZ2V0UGVuZGluZ0NvbnRpbnVhYmxlUHJvbWlzZShhdG9tU3RhdGUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLm0uZC5oYXMoYSkpIHtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50QXRvbShwZW5kaW5nLCBhKTtcbiAgICAgICAgICBhTW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgICAgICBhdG9tU3RhdGUubS5kLmFkZChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5tLmQgfHwgW10pIHtcbiAgICAgICAgaWYgKCFhdG9tU3RhdGUuZC5oYXMoYSkpIHtcbiAgICAgICAgICBhdG9tU3RhdGUubS5kLmRlbGV0ZShhKTtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKHBlbmRpbmcsIGEpO1xuICAgICAgICAgIGFNb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBhTW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRBdG9tID0gKHBlbmRpbmcsIGF0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCFhdG9tU3RhdGUubSkge1xuICAgICAgcmVhZEF0b21TdGF0ZShwZW5kaW5nLCBhdG9tKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudEF0b20ocGVuZGluZywgYSk7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLm0gPSB7XG4gICAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIGQ6IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKSxcbiAgICAgICAgdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBkZWJ1Z01vdW50ZWRBdG9tcy5hZGQoYXRvbSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBY3R1YWxseVdyaXRhYmxlQXRvbShhdG9tKSAmJiBhdG9tLm9uTW91bnQpIHtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IGF0b21TdGF0ZS5tO1xuICAgICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICAgIGFkZFBlbmRpbmdGdW5jdGlvbihwZW5kaW5nLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudChcbiAgICAgICAgICAgICguLi5hcmdzKSA9PiB3cml0ZUF0b21TdGF0ZShwZW5kaW5nLCBhdG9tLCAuLi5hcmdzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgbW91bnRlZC51ID0gb25Vbm1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdG9tU3RhdGUubTtcbiAgfTtcbiAgY29uc3QgdW5tb3VudEF0b20gPSAocGVuZGluZywgYXRvbSkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlLm0gJiYgIWF0b21TdGF0ZS5tLmwuc2l6ZSAmJiAhQXJyYXkuZnJvbShhdG9tU3RhdGUubS50KS5zb21lKChhKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gZ2V0QXRvbVN0YXRlKGEpLm0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kLmhhcyhhdG9tKTtcbiAgICB9KSkge1xuICAgICAgY29uc3Qgb25Vbm1vdW50ID0gYXRvbVN0YXRlLm0udTtcbiAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgYWRkUGVuZGluZ0Z1bmN0aW9uKHBlbmRpbmcsIG9uVW5tb3VudCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgYXRvbVN0YXRlLm07XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVidWdNb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5kLmtleXMoKSkge1xuICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKHBlbmRpbmcsIGEpO1xuICAgICAgICBhTW91bnRlZCA9PSBudWxsID8gdm9pZCAwIDogYU1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwZW5kaW5nUHJvbWlzZSA9IGdldFBlbmRpbmdDb250aW51YWJsZVByb21pc2UoYXRvbVN0YXRlKTtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZVtDT05USU5VRV9QUk9NSVNFXSh2b2lkIDAsICgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlLm07XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBwZW5kaW5nID0gY3JlYXRlUGVuZGluZygpO1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudEF0b20ocGVuZGluZywgYXRvbSk7XG4gICAgZmx1c2hQZW5kaW5nKHBlbmRpbmcpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICBjb25zdCBwZW5kaW5nMiA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgIHVubW91bnRBdG9tKHBlbmRpbmcyLCBhdG9tKTtcbiAgICAgIGZsdXNoUGVuZGluZyhwZW5kaW5nMik7XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b21cbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgZGV2U3RvcmUgPSB7XG4gICAgICAvLyBzdG9yZSBkZXYgbWV0aG9kcyAodGhlc2UgYXJlIHRlbnRhdGl2ZSBhbmQgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UpXG4gICAgICBkZXY0X2dldF9pbnRlcm5hbF93ZWFrX21hcDogKCkgPT4gYXRvbVN0YXRlTWFwLFxuICAgICAgZGV2NF9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gZGVidWdNb3VudGVkQXRvbXMsXG4gICAgICBkZXY0X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZVBlbmRpbmcoKTtcbiAgICAgICAgZm9yIChjb25zdCBbYXRvbSwgdmFsdWVdIG9mIHZhbHVlcykge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ByZXZWYWx1ZSA9IFwidlwiIGluIGF0b21TdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGF0b21TdGF0ZS52O1xuICAgICAgICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYXRvbSwgYXRvbVN0YXRlLCB2YWx1ZSk7XG4gICAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGF0b21TdGF0ZS52KSkge1xuICAgICAgICAgICAgICBhZGRQZW5kaW5nQXRvbShwZW5kaW5nLCBhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgICAgICAgICByZWNvbXB1dGVEZXBlbmRlbnRzKHBlbmRpbmcsIGF0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVzaFBlbmRpbmcocGVuZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHN0b3JlLCBkZXZTdG9yZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSAoKSA9PiB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gfHwgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gPSBkZWZhdWx0U3RvcmUpO1xuICAgICAgaWYgKGdsb2JhbFRoaXMuX19KT1RBSV9ERUZBVUxUX1NUT1JFX18gIT09IGRlZmF1bHRTdG9yZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSBKb3RhaSBpbnN0YW5jZXMuIEl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9yIHdpdGggdGhlIGRlZmF1bHQgc3RvcmUuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvam90YWkvZGlzY3Vzc2lvbnMvMjA0NFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0U3RvcmU7XG59O1xuXG5leHBvcnQgeyBhdG9tLCBjcmVhdGVTdG9yZSwgZ2V0RGVmYXVsdFN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jotai/esm/vanilla.mjs\n"));

/***/ })

});